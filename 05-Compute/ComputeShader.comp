#version 450

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (set = 0, binding = 0) uniform Constants
{
	float g_elapsedTime;
	float g_padding0;
	float g_padding1;
	float g_padding2;
};

layout (set = 0, binding = 1, rgba8) uniform writeonly image2D outputImage;

#define ID_ENV 0
#define ID_SPHERE 1
#define ID_PLANE 2
#define far_dist 1000.0

struct ray
{
	vec3 o;
	vec3 d;
};

struct sphere
{
	vec3 c;
	float r;
};

struct plane
{
	vec3 n;
	float d;
};

struct intersection
{
	vec3 n;
	vec3 p;
	float t;
};

struct surface
{
	int id;
	vec3 p;
	vec3 n;
	vec3 e;
	vec3 a;
};

intersection ray_plane(ray r, plane p)
{
	intersection res;

	res.t = far_dist;

	float t = (p.d - dot(r.o, p.n)) / dot(r.d, p.n);

	if (t < 0.0)
	{
		return res;
	}

	res.p = r.o + r.d * t;
	res.t = t;
	res.n = p.n;

	return res;
}

intersection ray_sphere(ray r, sphere s)
{
	intersection res;
	res.t = far_dist;

	vec3 local_ro = r.o - s.c;

	float b = 2.0 * dot(local_ro, r.d);
	float c = dot(local_ro, local_ro) - s.r * s.r;
	float d = b * b - 4.0 * c;

	if (d < 0.0)
	{
		return res;
	}

	float t = (-b - sqrt(d)) / 2.0;
	if (t < 0.0)
	{
		return res;
	}

	res.t = t;
	res.p = r.o + r.d * res.t;
	res.n = normalize(res.p - s.c);

	return res;
}

mat3 look_at(vec3 p, vec3 t)
{
	vec3 d = normalize(t - p);

	vec3 up = vec3(0.0, 1.0, 0.0);
	vec3 right = normalize(cross(up, d));
	up = cross(d, right);

	return mat3(right, up, d);
}

vec3 sampleEnvironment(vec3 d)
{
	return 0.25 * vec3(d * 0.5 + 0.5).bgr;
}

vec3 sampleGround(vec2 p)
{
	p *= 5.0;
	return vec3(fract(p.x), fract(p.y), 0.0);
}

surface raytrace(ray r, float elapsedTime)
{
	surface res;
	res.id = ID_ENV;
	res.p = r.o + r.d * far_dist;
	res.n = -r.d;
	res.e = r.d;
	res.a = sampleEnvironment(r.d);

	float t = far_dist;

	intersection i;

	{
		sphere s;
		s.c = 1.25 * vec3(cos(elapsedTime * 2.0), 0.0, sin(elapsedTime * 2.0));
		s.r = 0.25;
		i = ray_sphere(r, s);
		if (i.t < t)
		{
			res.id = ID_SPHERE;
			res.p = i.p;
			res.n = i.n;
			res.e = r.d;
			res.a = vec3(0.1, 1.0, 0.2);
			t = i.t;
		}
	}

	{
		sphere s;
		s.c = -1.25 * vec3(cos(elapsedTime * 2.0), 0.0, sin(elapsedTime * 2.0));
		s.r = 0.25;
		i = ray_sphere(r, s);
		if (i.t < t)
		{
			res.id = ID_SPHERE;
			res.p = i.p;
			res.n = i.n;
			res.e = r.d;
			res.a = vec3(1.0, 0.2, 0.1);
			t = i.t;
		}
	}

	{
		sphere s;
		s.c = vec3(0.0);
		s.r = 1.0;
		i = ray_sphere(r, s);
		if (i.t < t)
		{
			res.id = ID_SPHERE;
			res.p = i.p;
			res.n = i.n;
			res.e = r.d;
			res.a = vec3(1.0);
			t = i.t;
		}
	}

	{
		plane p;
		p.n = vec3(0.0, 1.0, 0.0);
		p.d = -1.0;
		i = ray_plane(r, p);
		if (i.t < t)
		{
			res.id = ID_PLANE;
			res.p = i.p;
			res.n = i.n;
			res.e = r.d;
			res.a = sampleGround(i.p.xz * 0.25);
			t = i.t;
		}
	}

	return res;
}

vec3 evaluate(surface surf)
{
	return surf.a;
}

void main()
{
	uvec3 dtid = gl_GlobalInvocationID;
	ivec2 outputSize = imageSize(outputImage);

	vec2 resolution = vec2(outputSize);
	vec2 uv = vec2(dtid.xy) / resolution;
	uv.y = 1.0 - uv.y;

	vec3 res = vec3(0.0);

	ray r;
	r.o = vec3(2.0 * cos(15.0 + g_elapsedTime * 0.2),
	           0.25 + sin(5.0 + g_elapsedTime * 0.05),
	           4.0 * sin(g_elapsedTime * 0.1));
	r.d = vec3(uv * 2.0 - 1.0, 1.0);
	r.d.x *= resolution.x / resolution.y;
	r.d = look_at(r.o, vec3(0.0)) * normalize(r.d);

	int num_bounces = 0;
	const int max_bounces = 3;
	surface surfaces[max_bounces];

	for (int i = 0; i < max_bounces; ++i)
	{
		++num_bounces;
		surface surf = raytrace(r, g_elapsedTime);
		surfaces[i] = surf;
		if (surf.id == ID_ENV)
		{
			break;
		}
		r.d = reflect(surf.e, surf.n);
		r.o = surf.p + r.d * 0.001;
	}

	for (int i = max_bounces - 1; i >= 0; --i)
	{
		float dp = clamp(dot(-surfaces[i].e, surfaces[i].n), 0.0, 1.0);
		float f = pow(1.0 - dp, 4.0);
		res = mix(evaluate(surfaces[i]), res, f);
	}

	imageStore(outputImage, ivec2(dtid.xy), vec4(res, 1.0));
}
