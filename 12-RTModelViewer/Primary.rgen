#version 460
#extension GL_NV_ray_tracing : enable

#include "Common.glsl"

layout(location = 0) rayPayloadNV DefaultPayload payload;

vec3 getCameraViewVector(vec2 uv)
{
	vec3 viewVector = vec3((uv-0.5) * 2, 1);
	viewVector.x /= matProj[0].x;
	viewVector.y /= matProj[1].y;
	return normalize(viewVector * transpose(mat3(matView)));
}

float randomFloat(inout uint seed)
{
	seed = 214013 * seed + 2531011;
	return float(seed >> 16) * (1.0f / 65535.0f);
}

uint hashFnv1(uint x)
{
	uint state = 0x811c9dc5;
	for (uint i = 0; i < 4; ++i)
	{
		state *= 0x01000193;
		state ^= (x & 0xFF);
		x = x >> 8;
	}
	return state;
}

void main()
{
	ivec2 pixelIndex = ivec2(gl_LaunchIDNV.xy);
	vec2 pixelUV = vec2(pixelIndex)/vec2(outputSize);

	uint pixelLinearIndex = pixelIndex.x + pixelIndex.y * outputSize.y;
	uint randomSeed = hashFnv1(pixelLinearIndex + pixelLinearIndex * 1294974679 + frameIndex);

	uint rayFlags = gl_RayFlagsOpaqueNV;

	payload.hitT = 0;

	vec2 pixelJitter;
	pixelJitter.x = (randomFloat(randomSeed) - 0.5) / outputSize.x;
	pixelJitter.y = (randomFloat(randomSeed) - 0.5) / outputSize.y;

	RayDesc ray;
	ray.origin = cameraPosition.xyz;
	ray.direction = getCameraViewVector(pixelUV + pixelJitter);
	ray.minT = 0;
	ray.maxT = 1e9;

	traceNV(TLAS,
		rayFlags,		// uint rayFlags
		~0u, 			// uint cullMask
		0u,	 			// uint sbtRecordOffset
		1u, 			// uint sbtRecordStride
		0u,				// uint missIndex
		ray.origin,		// vec3 origin
		ray.minT,	    // float Tmin
		ray.direction,  // vec3 direction
		ray.maxT,		// float Tmax
		0				// int payload
	);

	vec4 result = vec4(pixelUV, 0, 1);

	if (payload.hitT >= 0)
	{
		result.rgb = payload.albedo;
	}
	else
	{
		result.rgb = normalize(ray.direction) * 0.5 + 0.5;
	}

	if (frameIndex > 0)
	{
		vec4 oldValue = imageLoad(outputImage, pixelIndex);
		result.rgb = mix(oldValue.rgb, result.rgb, 1.0 / (frameIndex+1));
	}

	imageStore(outputImage, pixelIndex, result);
}
